# js-12

# classes

- 클래스란 객체를 _생성_하는 틀이다

### class의 사용법

- 클래스의 기본 형태 : class 키워드 + 이름 + 중괄호
    
    ```jsx
    class Robot {
        // 클래스의 생성자 함수입니다. 하나의 클래스는 하나의 생성자만 정의할 수 있습니다. 
    		// 그리고 생성자 함수는 new 키워드가 호출될때 자동으로 실행됩니다.
        constructor(name) {
            this.name = name;
        }
    
        // 메소드를 정의합니다. 메소드는 클래스가 생성한 인스턴스를 통해 사용할 수 있습니다.
        sayYourName() {
            console.log(`삐리비리. 제 이름은 ${this.name}입니다. 주인님.`);
        }
    }
    ```
    

### class 상속받기

- `extend` 키워드 사용
- `super` : 상속을 받기 위해 사용하는 함수
    - 사용 시 주의점
        - 파생 클래스에 생성자 함수를 사용하고 싶다면 반드시 super 함수를 사용해야 한다.
        - 파생 클래스에 생성자 함수가 없다면 super 함수가 자동으로 호출되어 부모 클래스의 프로퍼티를 상속 받게 한다.
        - 생성자 함수에서 this 값을 사용할 경우 super 함수는 반드시 this 보다 먼저 실행되어야 한다.
        - 파생 클래스가 아닌 클래스에서 사용하려고 해도 에러가 발생한다.

### 비공개(Private) 프로퍼티

- 사용하는 상황 :  중요한 데이터를 조심스럽게 다뤄야 할 경우, 그래서 이런 데이터를 외부에서 함부로 수정할 수 없게 만들고 싶을 때
- 비공개 프로퍼티의 역할 : 객체 안의 중요한 정보를 안전하게 보호하여 프로그램이 뜻하지 않게 변경되는 것을 막는 역할을 한다.
- 프로퍼티를 비공개로 전환할 떄에는 _`#`_키워드를 사용한다.
- 비공개 프로퍼티에 접근/수정하기 위한 키워드
    - `get` : 값에 접근
    - `set` : 값을 수정
    - 사용 시 주의 점 :
        - 마치 객체의 프로퍼티를 수정하는것 같은 간편함을 느낄 수 있다.
        - private 필드 선언을 한 프로퍼티의 경우 get, set 키워드를 사용하면, 비공개 하였음에도 불구하고 일반 프로퍼티처럼 접근이 가능하게 된다.
        - 협업 시에는 주석이나, 가이드 문서를 만들어 충분한 정보를 제공 해주는 것이 좋다.

# AJAX

## AJAX란?

- Asynchronous JavaScript and XML, JavaScript와 XML을 이용한 비동기적 정보 교환 기법.

## 동기 VS 비동기

- 동기 실행 방식 : 작업을 순차적으로 처리하며, 다음 작업을 **실행**하기 위해 이전 작업의 완료를 기다린다.
- 비동기 실행 방식 : 작업을 독립적으로 **실행**하며, 다른 작업을 **실행**하면서 작업의 완료를 기다리지 않는다.
- **동기**와 **비동기**의 선택은 프로그램의 요구사항과 성능에 따라 달라진다.

## XMLHttpRequest

- 어떤 기능을 가진 객체인가요? : 서버와의 비동기 통신을 가능하게 하는 여러 기능들을 가진 자바스크립트 객체다.

### Call back지옥이란?

 **콜백 함수를 중첩하여 사용할 때 코드가 복잡해지고 가독성이 저하되는 현상**을 말한다. 비동기 작업이 많이 포함된 코드에서는 콜백 함수의 중첩이 깊어질 수 있으며, 이로 인해 코드의 이해와 유지 보수가 어려워진다.

자바스크립트 엔진은 비동기 코드가 끝날때까지 다른 코드의 실행을 멈추지 않기 때문이다.

## fetch API

- fetch의 보편적 의미 : fetch는 여러가지 뜻이 있지만 여기서는 ‘가져오다, 찾아내다’의 의미로 사용되고 있다.

### XHR과 fetch

- 차이점은? :  XMLHttpRequest 가 생성하는 인스턴스는 통신의 기능을 수행하는 XMLHttpRequest 객체를 반환했지만 fetch는 인스턴스를 만들지 않고, 대신 ‘약속’을 반환한다.

### Promise

- Promise란? : 프로미스가 생성된 시점에는 알려지지 않았을 수도 있는 값을 위한 대리자로, 비동기 연산이 종료된 이후에 결과 값과 실패 사유를 처리하기 위한 처리기를 연결할 수 있다. 프로미스를 사용하면 비동기 메서드에서 마치 동기 메서드처럼 값을 반환할 수 있다. 다만 최종 결과를 반환하는 것이 아니고, 미래의 어떤 시점에 결과를 제공하겠다는 프로미스를 반환한다.
- 통신 상태가 거절일 때의 처리 방법 : .catch( ) 를 사용해서 에러를 띄운다.

### fetch API 사용

- 기본 형태 :  **fetch(url, options) .** **then(response => response.json())**
- json을 받는 예시 :

```jsx
fetch('https://mdn.github.io/learning-area/javascript/oojs/json/superheroes.json')
	.then((response) => {
			// response.ok 는 응답이 성공적(200-299)일 경우 true, 아니면 false를 반환합니다.
	    if (!response.ok) {
	        throw new Error(`HTTP error! Status: ${response.status}`);
	    }
	    return response.json();
	})
	.then((data) => {
	    console.log(data);
	    return data;
	})
	// fetch 함수는 네트워크 오류가 발생하면 reject 상태의 프로미스를 반환합니다. 
	.catch((error) => {
	    console.error(error);
	});
```

## async, await

- 특징 : async 키워드는 어떤 함수든 프로미스 객체를 반환하게 만들 수 있다. (심지어 return 키워드가 없어도!)
    
    await 는 async 함수 안에서 promise 객체의 상태가 결정될 때까지 다음 코드를 실행시키지 않고 기다리게 만들어준다. 그리고 프로미스 객체의 fulfilled 값을 반환한다.
    또한 await 는 반드시 async 함수 안에서만 사용할 수 있다.
    
    await의 중요한 특징은 바로 async 함수 안에서 코드의 실행 순서를 확정 지을 수 있다는 것이다. 비동기적 코드를 동기적으로 전환함으로서, async를 이용하면 기존의 Promise를 이용하는 것보다 더 가독성 있는 코드를 만들 수 있다.